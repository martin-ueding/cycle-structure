#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Copyright Â© 2014 Martin Ueding <dev@martin-ueding.de>

import argparse
import math

import jinja2

def insert_partitions(part, n, i, parts):
    free = n - sum(part)

    if i == n:
        if free != 0:
            return
        parts.append(list(part))
    else:
        max_element = free
        if i != 0:
            max_element = min(max_element, part[i-1])

        for k in reversed(range(max_element + 1)):
            part[i] = k
            insert_partitions(part, n, i + 1, parts)

def partitions(n):
    part = [0]*n
    parts = []

    insert_partitions(part, n, 0, parts)

    return parts

def render_part_long(part):
    return '[' + ', '.join([str(x) for x in part]) + ']'

def render_part_short(part):
    output = []
    output.append('[')
    powers = []
    prev = None
    power = 1

    i = 0
    while i != len(part):
        lambda_ = part[i]
        if lambda_ == 0:
            break
        power = len(list(filter(lambda x: x == lambda_, part)))
        if power == 1:
            powers.append('{}'.format(lambda_))
        else:
            powers.append('{}^{}'.format(lambda_, power))
        i += power
    output += ', '.join(powers)
    output.append(']')

    return ''.join(output)

def render_young_frame(part):
    lines = []
    n = sum(part)
    for lambda_ in part:
        if lambda_ == 0:
            break
        lines.append('#' * lambda_)

    return '\n'.join(lines)

def pertinent_cycle_structure(part):
    n = sum(part)
    cycle_lengths = [0] * n

    for i in range(n):
        lambda_ = part[i]
        for j in range(lambda_):
            cycle_lengths[j] += 1

    structure = {}

    i = 0
    while i < n:
        cycle_length = cycle_lengths[i]
        if cycle_length == 0:
            i += 1
            continue
        power = len(list(filter(lambda x: x == cycle_length, cycle_lengths)))
        structure[cycle_length] = power
        i += power

    return structure

def render_pertinent_cycle_structure(part):
    structure = pertinent_cycle_structure(part)
    output = []

    for cycle_length, count in reversed(sorted(structure.items())):
        i_cycle = '(' + '.'*cycle_length + ')'
        output.append(i_cycle*count)

    return ''.join(output)

def number_in_conjugacy_class(part):
    structure = pertinent_cycle_structure(part)

    n = len(part)

    number = math.factorial(n)
    for cycle_length, count in structure.items():
        number //= cycle_length**count
        number //= math.factorial(count)

    return number


def main():
    options = _parse_args()

    env = jinja2.Environment(loader=jinja2.FileSystemLoader("."))
    template = env.get_template("partitions.html.j2")

    parts = partitions(options.n)

    t_list = []

    for part in parts:
        T = {}
        T['part_long'] = render_part_long(part)
        T['part_short'] = render_part_short(part)
        T['young_frame'] = render_young_frame(part)
        T['pertinent_cycle_structure'] = render_pertinent_cycle_structure(part)
        T['number'] = number_in_conjugacy_class(part)

        t_list.append(T)

    with open("partitions.html", "w") as f:
        f.write(template.render({
            't_list': t_list,
        }))


def _parse_args():
    '''
    Parses the command line arguments.

    :return: Namespace with arguments.
    :rtype: Namespace
    '''
    parser = argparse.ArgumentParser(description='')
    parser.add_argument('n', type=int)
    options = parser.parse_args()

    return options

if __name__ == '__main__':
    main()
